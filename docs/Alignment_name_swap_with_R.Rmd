# Swapping FASTA Sequence Names in R with Biostrings

This tutorial demonstrates how to use R with the Biostrings package to replace generic sequence IDs in FASTA files with informative taxonomic labels.

## Setup and Required Packages

```{r,message=FALSE,warning=FALSE}
# Install required packages if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

if (!requireNamespace("Biostrings", quietly = TRUE))
  BiocManager::install("Biostrings")

if (!requireNamespace("tidyverse", quietly = TRUE))
  install.packages("tidyverse")

# Load packages
library(Biostrings)  # For FASTA manipulation
library(tidyverse)   # For data manipulation
```

## Step 1: Read Mapping Files

First, let's load the mapping tables that connect sequence IDs to taxa names:

```{r}
# Read the mapping table
metadata <- read.csv("~/Desktop/seqid_label.csv")

# Display the first few rows of each
head(metadata)

```

## Step 2: Read the FASTA Alignment File

Next, we'll read the original FASTA alignment using Biostrings:

```{r}
# Read FASTA alignment
aln_file <- "~/Desktop/name_swap/hpc1_aligned.fasta"
original_alignment <- readDNAStringSet(aln_file)

# View some information about the alignment
length(original_alignment)  # Number of sequences
width(original_alignment)   # Sequence lengths
```

## Step 3: Filter Sequences of Interest

Let's filter the alignment to keep only our samples of interest:

```{r}
# Create a vector of sequences to keep (reference sequences + samples)
# samples_to_keep <- c("hpc1_B73", "hpc1_TIL18", paste0("hpc1_", sample_label$sample))

# Filter the alignment
# filtered_alignment <- original_alignment[names(original_alignment) %in% samples_to_keep]

# Check how many sequences we have now
# length(filtered_alignment)

# filtered_alignment <- original_alignment
```

## Step 4: Create a Complete Name Mapping Table



```{r}
# Extract sequence IDs from the filtered alignment

seq_ids <- names(original_alignment)
# remove description field
trimmed_ids <- gsub("\\s.*", "", seq_ids, perl=TRUE)
length(trimmed_ids)
length(original_alignment)
names(original_alignment) <- trimmed_ids


colnames(metadata)
name_swap <- data.frame(seqid = trimmed_ids) %>%
   mutate(aln_order = row_number()) %>%
  inner_join(metadata)

name_swap  <- name_swap %>%
  dplyr::filter(seqid %in% names(original_alignment))
nrow(name_swap)
filtered_alignment <- original_alignment[name_swap$seqid]
names(filtered_alignment) <- name_swap$label_3 
n_taxa <- length(filtered_alignment)
n_pos <- width(filtered_alignment)
filtered_alignment
library(GenomicRanges)
trimmedRanges <- GRanges(seqnames = names(filtered_alignment) ,
                    ranges = IRanges(start = rep(2226,n_taxa),
                                     end = n_pos)
)
trimmed_alignment <- filtered_alignment[trimmedRanges]
names(trimmed_alignment)

# get the positiov of I211V
trimmed_alignment

I211V_B73 <-vmatchPattern("ATCACCCGC", trimmed_alignment)[[1]]

I211V_range <- GRanges(
  seqnames = names(filtered_alignment) ,
              ranges = IRanges(start = rep(start(I211V_B73),n_taxa),
                               end = rep(start(I211V_B73),n_taxa))
)

I211V_aln <-trimmed_alignment[I211V_range]
I211V_matrix <- as.matrix(I211V_aln)
I211V_matrix[I211V_matrix=="-"] <- NA 
I211V_matrix
name_swap$I211V <- factor(as.vector(I211V_matrix))



```

## Step 5: Replace Sequence Names and Write New FASTA

Finally, we'll apply the mapping and write out the new alignment:

```{r}
# Write the renamed alignment to a new file
writeXStringSet(trimmed_alignment, "~/Desktop/hpc1_nice_labels.fasta", format="fasta")
```

## Step 6: Make phylogenetic Tree

```{r}
library(ape)

# Pivot tree on tip, so the tip gets on top.

pivot_on <- function(x, target_tip){
  target_tip_label <-target_tip
    tree <- x
  # Make a copy to modify, keeping the original intact
  rotated_tree <- tree
  
  # Check if the target tip exists in the tree
  if (!target_tip_label %in% rotated_tree$tip.label) {
    stop("Target tip '", target_tip_label, "' not found in the tree.")
  }
  
  # Get the total number of tips
  ntips <- Ntip(rotated_tree)
  
  # Get the node number corresponding to the target tip
  target_tip_node <- which(rotated_tree$tip.label == target_tip_label)
  
  # Get the reference node number 
  # The tree might not be rooted
  # choose a reference node to find a path around which to do the rotations 
  # maybe TIL18?
  reference_node <- ntips 
  
  
  node_path <- nodepath(rotated_tree, from = reference_node, to = target_tip_node)
  
  # We only need to consider rotating the *internal* nodes on the path
  # Exclude the root (first element) and the tip itself (last element)
  internal_nodes_on_path <- node_path[node_path > ntips & node_path != root_node]
  
  # Iterate through the internal nodes on the path, starting from the one
  # closest to the root.
  # For each node, check the order of its children. If the child leading
  # towards our target tip is currently the 'first' child (which ape usually
  # plots lower/towards the bottom in a rightward phylogram), rotate the node
  # so that the child leading to the target tip becomes the 'second' child
  # (plotted higher/towards the top).
  
  if (length(internal_nodes_on_path) > 0) {
    # Order matters: Process nodes from root towards tip
    nodes_to_check <- sort(internal_nodes_on_path)
    
    for (node_to_rotate in nodes_to_check) {
      # Find the direct children of this internal node
      children <- rotated_tree$edge[rotated_tree$edge[, 1] == node_to_rotate, 2]
      
      # Should always have 2 children for a bifurcating tree
      if (length(children) != 2) {
        warning("Node ", node_to_rotate, " is not bifurcating. Rotation might not work as expected.")
        next # Skip rotation for non-bifurcating nodes
      }
      
      # Find which child is on the path towards the target tip
      # It will be the next node in the full node_path sequence
      current_node_index_in_path <- which(node_path == node_to_rotate)
      child_on_path <- node_path[current_node_index_in_path + 1]
      
      # Check if the child *on the path* is the *first* child listed in the edge table
      # If it is, rotating the node will swap it to the second position.
      if (child_on_path == children[1]) {
        # Rotate the tree at this node
        # The rotate function returns the modified tree object
        rotated_tree <- rotate(rotated_tree, node = node_to_rotate)
        # Note: After rotation, the edge table and potentially node numbers
        # for descendants might change, but nodepath should still be valid
        # relative to the *original* topology's node identities if we recalculate path,
        # or simply proceed as the fundamental connections remain.
        # Sticking to the original path nodes should be fine.
      }
    }
  }
  rotated_tree
}



library(phangorn)
library(phytools)
hpc1_aln <- read.dna("~/Desktop/hpc1_nice_labels.fasta", format="fasta")
labels(hpc1_aln)
hpc1_phyDat <- phyDat(hpc1_aln, type = "DNA", levels = NULL)
# mt <- modelTest(hpc1_phyDat)
dna_dist <- dist.ml(hpc1_phyDat, model="JC69") #?


hpc1_UPGMA <- ladderize(upgma(dna_dist),right = FALSE)
name_swap$founder_ancestry <- factor(name_swap$founder_ancestry, c("Recurrent","Donor"))




plot_output <- function(file, tree,data){ 
  data <- data %>% dplyr::rename(ancestry="founder_ancestry")
  pal <- c("gold","purple3","tomato","royalblue")
  names(pal) <-  c("Recurrent","Donor","A","G")
  X <- data[,c("ancestry","I211V")]
  rownames(X) <- rownames(data) 
  pdf(file=file,height = 13,width =7)
  dotTree(tree ,X,colors= pal,labels=TRUE, fsize=0.8,border="transparent",cex.dot=2)
  dev.off()
}

rownames(name_swap) <- name_swap$label_5
hpc1_UPGMA$tip.label <- name_swap$label_5
out_tree<-pivot_on(hpc1_UPGMA, hpc1_UPGMA$tip.label[1]) 
quartz(height = 13,width =7);plot(out_tree)
name_swap[,c("founder_ancestry","I211V")]
plot_output("~/Desktop/hpc1_UPGMA_dot_tree.pdf", 
            out_tree,
            name_swap)

write.tree(rotated_tree, file="~/Desktop/hpc1_UPGMA.tre")
```

## Advantages of the R Approach

1. **Readability**: The R code is more self-explanatory than complex bash commands
2. **Flexibility**: Easy to modify for different naming patterns or additional data processing
3. **Error Handling**: Better handling of edge cases and missing mappings
4. **Integration**: Can be part of a larger R-based bioinformatics workflow
5. **Visualization**: Can easily add sequence visualization or analysis in the same script

This approach eliminates the need for intermediate files and complex awk or grep commands, making the process more streamlined and reproducible.