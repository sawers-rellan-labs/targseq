---
title: "Maize Phylogeny Analysis with Multiple Variants"
author: "Maize Genetics Lab"
date: "`r Sys.Date()`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

This tutorial walks through a complete workflow for processing maize genetic data, focusing on:

1. Relabeling sequence identifiers in a FASTA alignment with meaningful taxonomic labels
2. Extracting genotype information at multiple variant positions (I211V and A204T)
3. Creating a phylogenetic tree with ancestry and variant information
4. Rotating the tree to position the B73 reference genome at the top

## 1. Setting up the Environment

First, let's install and load the necessary packages:

```{r load_packages}
# Install required packages if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

if (!requireNamespace("Biostrings", quietly = TRUE))
  BiocManager::install("Biostrings")

if (!requireNamespace("tidyverse", quietly = TRUE))
  install.packages("tidyverse")

# Load packages
library(Biostrings)  # For FASTA manipulation
library(tidyverse)   # For data manipulation
```

## 2. Reading Input Files

Let's set up our directory structure and read our input files:

```{r read_inputs}
# Create a project directory if it doesn't exist
project_dir <- "/pathway_to/tree_plotting"
if (!dir.exists(project_dir)) {
  dir.create(project_dir)
}

# Set file paths within the project directory
aln_file <- file.path(project_dir, "hpc1_aligned.fasta")
metadata_file <- file.path(project_dir, "seqid_label.csv")

# Read the mapping table with taxonomic metadata
metadata <- read.csv(metadata_file)

# Display the first few rows to understand the structure
head(metadata)

# Read the FASTA alignment using Biostrings
original_alignment <- readDNAStringSet(aln_file)

# View information about the alignment
cat("Number of sequences:", length(original_alignment), "\n")
cat("Sequence length:", width(original_alignment)[1], "bp\n")

# Display the first few sequence names
head(names(original_alignment))
```

## 3. Creating the Name Mapping Table

Now we'll prepare our sequence names and map them to meaningful labels:

```{r create_mapping}
# Extract sequence IDs from the alignment and remove description fields
seq_ids <- names(original_alignment)
trimmed_ids <- gsub("\\s.*", "", seq_ids, perl=TRUE)

# Verify sequence ID counts match
cat("Original sequence count:", length(original_alignment), "\n")
cat("Trimmed IDs count:", length(trimmed_ids), "\n")

# Assign the trimmed IDs to the alignment object
names(original_alignment) <- trimmed_ids

# Create a mapping dataframe that connects sequence IDs with taxonomic labels
# We also keep track of the original order in the alignment
name_swap <- data.frame(seqid = trimmed_ids) %>%
  mutate(aln_order = row_number()) %>%
  inner_join(metadata)

# Filter to include only sequences that exist in our alignment
name_swap <- name_swap %>%
  dplyr::filter(seqid %in% names(original_alignment)) %>%
  rename(ancestry_call ="founder_ancestry")
rownames(name_swap) <- name_swap$label_3

# Report on mapping success
cat("Sequences successfully mapped:", nrow(name_swap), "\n")

# Filter the alignment to keep only sequences we have metadata for
filtered_alignment <- original_alignment[name_swap$seqid]

# Now replace the technical IDs with meaningful labels from label_3 column
names(filtered_alignment) <- name_swap$label_3

# Store counts for later use
n_taxa <- length(filtered_alignment)
n_pos <- width(filtered_alignment)[1]

# Examine our newly labeled sequences
head(names(filtered_alignment))
```

## 4. Trimming the Alignment

Next, we'll trim the alignment to focus on the region of interest:

```{r trim_alignment}
# Load GenomicRanges for efficient sequence manipulation
library(GenomicRanges)

# Define trimming ranges (starting from position 2226 to the end)
trimmedRanges <- GRanges(
  seqnames = names(filtered_alignment),
  ranges = IRanges(
    start = rep(2226, n_taxa),
    end = rep(n_pos, n_taxa)
  )
)

# Perform the trimming operation
trimmed_alignment <- filtered_alignment[trimmedRanges]

# Verify the trimmed alignment
cat("Trimmed alignment length:", width(trimmed_alignment)[1], "bp\n")
head(names(trimmed_alignment))
```

## 5. Extracting Variant Information

Now we can extract information for both variants using our function:

```{r extract_variants}
# Define our variants
variants <- data.frame(
  name = c("A204T","I211V"),
  pattern = c( "GCCGTGGCGTGGCGC", "ATCACCCGC")
)

variant_data <- get_variant_gt(variants,alignment)
variant_data$A204T<- c("ALT","REF")[as.factor(variant_data$A204T)]
variant_data$I211V<- c("REF","ALT")[as.factor(variant_data$I211V)]
rownames(variant_data)<- name_swap$label_3
```

## 7. Writing the Processed Alignment to a New File

Let's save our relabeled and trimmed alignment:

```{r write_alignment}
# Define output file path
output_alignment <- file.path(project_dir, "hpc1_nice_labels.fasta")

# Write the renamed alignment to a new file
writeXStringSet(trimmed_alignment, output_alignment, format="fasta")
cat("Renamed alignment written to:", output_alignment, "\n")
```

## 8. Building a Phylogenetic Tree

Now we'll build and visualize a phylogenetic tree from our processed alignment:

```{r build_tree}
# Load packages for phylogenetic analysis
library(ape)
library(phangorn)
library(phytools)

# Read the renamed alignment for phylogenetic analysis
hpc1_aln <- read.dna(output_alignment, format="fasta")

# Check labels in the alignment
labels(hpc1_aln)

# Convert to phangorn's phyDat format for phylogenetic analysis
hpc1_phyDat <- phyDat(hpc1_aln, type = "DNA", levels = NULL)

# Calculate distance matrix using JC69 model
# Note: You could use modelTest() to find the best model for your data
# mt <- modelTest(hpc1_phyDat)
dna_dist <- dist.ml(hpc1_phyDat, model="JC69")

# Build UPGMA tree and ladderize it for better visualization
hpc1_UPGMA <- ladderize(upgma(dna_dist), right = FALSE)

# Simple plot to check the tree
plot(hpc1_UPGMA, cex = 0.7, main = "UPGMA Tree Before Rotation")
```

## 10. Visualizing the Full Tree with ggtree
Now we'll create comprehensive tree visualizations with variant information using ggtree. This approach provides more flexibility and better integration of multiple data types compared to base R plotting.nd load the ggtree package and its dependencies:

```{r ggtree_setup}
# Install required packages if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

if (!requireNamespace("ggtree", quietly = TRUE))
  BiocManager::install("ggtree")

if (!requireNamespace("ggplot2", quietly = TRUE))
  install.packages("ggplot2")

if (!requireNamespace("ggnewscale", quietly = TRUE))
  install.packages("ggnewscale")

# Load packages
library(ggtree)     # For tree visualization
library(ggplot2)    # For plotting
library(ggnewscale) # For multiple color scales in the same plot
library(dplyr)      # For data manipulation
```

Now let's apply our rotation function and create plots using ggtree:

```{r ggtree_full_visualization}
# First, ensure row names in our metadata match the tree's tip labels
# This is critical for proper data mapping in ggtree


# Rotate the tree to put B73 reference at the top
# This uses our custom pivot_on function from the previous section
out_tree <- pivot_on(hpc1_UPGMA, hpc1_UPGMA$tip.label[1]) 

# Save the full phylogenetic tree for future use
tree_file <- file.path(project_dir, "hpc1_UPGMA.tre")
write.tree(out_tree, file = tree_file)
cat("Full phylogenetic tree saved to:", tree_file, "\n")

# Create a basic tree visualization with the alignment
# This provides a comprehensive view of sequence difference

# Ensure ancestry call is properly formatted as a factor
# Note how we specify the order of levels to control the color scheme
variant_data <- variant_data[out_tree$tip.label,]
rownames(variant_data) <- out_tree$tip.label
tree_data  <- name_swap %>% select(label= label_3,ancestry_call) # I need  this label field
tree_data  <- tree_data[out_tree$tip.label, ,drop =FALSE]

pal <- c ("Recurrent" = "tomato", "Donor" = "royalblue")

variant_heatmap <- create_variant_heatmap_tree( 
  tree = out_tree, 
  data = variant_data
  ) %<+% tree_data  +
  geom_tippoint(aes(color = ancestry_call), position = position_nudge(x = 0.0015)) +
  scale_color_manual(values=pal) +
  theme(legend.position = c(0.25,0.5))

output_heatmap <- file.path(project_dir, "hpc1_all_samples_variants.pdf")
  
ggsave(variant_heatmap, file = output_heatmap,height =12)

# Add multiple alignment overview

# Create a combination plot with both the tree+heatmap and alignment visualization
p2 <- msaplot(variant_heatmap, 
              fasta = file.path(project_dir, "hpc1_nice_labels.fasta"), 
              offset = 0.05, width = 0.6) +
      theme(legend.position = "none")

# Save both visualization types
ggsave(p2, file = file.path(project_dir, "hpc1_all_samples_aln.pdf"), 
       height = 12, width = 9, units = "in")


```

## 11. Subsetting and Visualizing Donor Taxa with ggtree

Now we'll create a subset analysis focusing only on taxa with donor ancestry plus the B73 reference:

```{r ggtree_subset_visualization}
# First, identify B73 in our dataset
b73_label <- grep("B73", name_swap$label_2, value = TRUE)[1]
cat("B73 reference identified as:", b73_label, "\n")

# Create a subset of taxa with donor ancestry plus B73
donor_subset <- name_swap %>%
  filter(founder_ancestry == "Donor" | label_2 == b73_label)

# Check how many taxa we have in our subset
cat("Number of taxa in donor subset:", nrow(donor_subset), "\n")

# Extract the subset of sequences from our alignment
donor_alignment <- trimmed_alignment[donor_subset$label_2]

# Write the subset alignment to a file
donor_alignment_file <- file.path(project_dir, "hpc1_donor_subset.fasta")
writeXStringSet(donor_alignment, donor_alignment_file, format="fasta")
cat("Donor subset alignment written to:", donor_alignment_file, "\n")



  
# Build a new tree for the donor subset
donor_aln <- read.dna(donor_alignment_file, format="fasta")
donor_phyDat <- phyDat(donor_aln, type = "DNA", levels = NULL)
donor_dist <- dist.ml(donor_phyDat, model="JC69")
donor_UPGMA <- ladderize(upgma(donor_dist), right = FALSE)

# Rotate the donor tree to put B73 at the top
donor_tree <- pivot_on(donor_UPGMA, b73_label) 

# Save the donor subset tree
donor_tree_file <- file.path(project_dir, "hpc1_donor_subset.tre")
write.tree(donor_tree, file = donor_tree_file)
cat("Donor subset tree saved to:", donor_tree_file, "\n")

# addd multiple alignment

p <- ggtree(donor_tree,ladderize = FALSE) + geom_tiplab(size=3)
p2 <- msaplot(p, fasta = donor_alignment_file, offset=0.05, width=0.6)+
        theme(legend.position = "none")
ggsave(p2, file= file.path(project_dir,"hpc1_donor_tree_alignment.png"), height=12, width=7, units = "in")
  
# Assuming you already have:
# 1. Your tree object (e.g., out_tree or donor_tree)
# 2. Your data with variant information (variants_ref_alt or donor_ref_alt)

# First, ensure your variant data has the correct REF/ALT coding
# For example:
variant_data <- name_swap[donor_subset$label_2,] %>%
  mutate(
      ancestry_call = case_when(
      founder_ancestry == "Recurrent" ~ "REF",
      founder_ancestry  == "Donor" ~ "ALT",
      TRUE ~ as.character(A204T) 
    ),
    A204T_state = case_when(
      A204T == "A" ~ "ALT",
      A204T == "G" ~ "REF",
      TRUE ~ as.character(A204T)
    ),
    I211V_state = case_when(
      I211V == "G" ~ "ALT",
      I211V == "A" ~ "REF",
      TRUE ~ as.character(I211V)
    )
  )  %>%   
 select(ancestry= ancestry_call, A204T=A204T_state, I211V=I211V_state)


# Convert state columns to factors
variant_data$ancestry <- factor(variant_data$ancestry, levels = c("REF","ALT"))
variant_data$A204T <- factor(variant_data$A204T, levels = c("REF","ALT"))
variant_data$I211V <- factor(variant_data$I211V, levels = c("REF","ALT"))

# Generate and save the heatmap visualization
output_heatmap <- file.path(project_dir,"hpc1_donor_subset.pdf")
variant_heatmap <- create_variant_heatmap_tree(donor_tree, variant_data)

p2 <- msaplot(variant_heatmap, fasta = donor_alignment_file , offset=0.05, width=0.6) +
  theme(legend.position = "none")
ggsave(p2, file= file.path(project_dir,"hpc1_donor_subset.png"), height=12, width=9, units = "in")
ggsave(variant_heatmap, file= output_heatmap )

```

## 12. Project File Structure with ggtree Outputs

Let's examine the complete file structure with all our inputs and outputs:

```{r file_structure, echo=FALSE, eval=TRUE}
# This chunk will be evaluated when knitting
# This chunk will be evaluated when knitting
cat("tree_plotting/\n")
cat("├── hpc1_aligned.fasta              # Input: Original alignment file\n")
cat("├── seqid_label.csv                 # Input: Metadata mapping file\n")
cat("├── hpc1_nice_labels.fasta          # Output: Alignment with renamed sequences\n")
cat("├── hpc1_donor_subset.fasta         # Output: Subset alignment with donor taxa + B73\n")
cat("├── hpc1_UPGMA.tre                  # Output: Full phylogenetic tree in Newick format\n")
cat("├── hpc1_donor_subset.tre           # Output: Donor subset tree in Newick format\n")
cat("├── hpc1_all_samples.pdf            # Output: Full tree visualization with variant heatmap\n")
cat("├── hpc1_tree_alignment.png         # Output: Full tree with sequence alignment visualization\n")
cat("├── hpc1_tree_alignment_with_heatmap.png # Output: Full tree with heatmap and alignment\n")
cat("├── hpc1_donor_subset.pdf           # Output: Donor subset tree with variant heatmap\n")
cat("├── hpc1_donor_tree_alignment.png   # Output: Donor subset tree with alignment visualization\n")
cat("└── hpc1_donor_subset_with_heatmap.png # Output: Donor subset with heatmap and alignment\n")
```

## 13. Advantages of ggtree Over Base R Plotting

The ggtree package offers several advantages over base R plotting functions for phylogenetic trees:

1. **Grammar of Graphics Approach**: Uses the familiar ggplot2 syntax for consistent and extensible visualizations.

2. **Layered Visualizations**: Easily add multiple data layers (geom_tippoint, geom_hilight, etc.) to the tree.

3. **Multiple Tree Layouts**: Supports rectangular, circular, fan, and other tree layouts without rewriting code.

4. **Integration with Other Data**: The `%<+%` operator makes it easy to map external data onto the tree.

5. **Publication-Ready Figures**: Creates high-quality vector graphics with customizable aesthetics.

6. **Highlighting and Annotation**: Easily highlight specific clades or nodes of interest.

7. **Multiple Output Formats**: Compatible with all ggplot2 output formats (PDF, PNG, SVG, etc.).

8. **Heatmap Integration**: The gheatmap function allows easy addition of heatmaps alongside trees.

## 14. Conclusion

This tutorial demonstrated how to use ggtree to create advanced visualizations of phylogenetic trees with variant and ancestry information. We created:

1. Full tree visualizations with nucleotide and REF/ALT variant coding
2. Subset analyses focusing on donor taxa plus the B73 reference
3. Multiple tree layouts (rectangular and circular)
4. Integrated heatmaps for variant visualization

These ggtree-based visualizations are more flexible and publication-ready compared to the base R plotting methods used previously.

## 15. Troubleshooting Tips

- **Missing data issues**: Use the `%<+%` operator from ggtree to properly map data to the tree tips.
- **Layout problems**: If the tree is too crowded, try adjusting the `width` and `height` parameters in `ggsave()`.
- **Label overlaps**: Use `geom_tiplab2()` with an appropriate `offset` value to prevent overlapping labels.
- **Color issues**: Define custom color palettes using `scale_color_manual()` or `scale_fill_manual()`.
- **Legend problems**: Adjust the legend position and box orientation with `theme()` options.