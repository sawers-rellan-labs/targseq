---
title: "Maize Phylogeny Analysis with Multiple Variants"
author: "Maize Genetics Lab"
date: "`r Sys.Date()`"
output:
  github_document:
    html_preview: false
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

This tutorial walks through a complete workflow for processing maize genetic data, focusing on:

1. Relabeling sequence identifiers in a FASTA alignment with meaningful taxonomic labels
2. Extracting genotype information at multiple variant positions (I211V and A204T)
3. Creating a phylogenetic tree with ancestry and variant information
4. Rotating the tree to position the B73 reference genome at the top

## 1. Setting up the Environment

First, let's install and load the necessary packages:

```{r load_packages}
# Install required packages if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

if (!requireNamespace("Biostrings", quietly = TRUE))
  BiocManager::install("Biostrings")

if (!requireNamespace("tidyverse", quietly = TRUE))
  install.packages("tidyverse")

# Load packages
library(Biostrings)  # For FASTA manipulation
library(tidyverse)   # For data manipulation
```

## 2. Reading Input Files

Let's set up our directory structure and read our input files:

```{r read_inputs}
# Create a project directory if it doesn't exist
project_dir <- "~/Desktop/tree_plotting"
if (!dir.exists(project_dir)) {
  dir.create(project_dir)
}

# Set file paths within the project directory
aln_file <- file.path(project_dir, "hpc1_aligned.fasta")
metadata_file <- file.path(project_dir, "seqid_label.csv")

# Read the mapping table with taxonomic metadata
metadata <- read.csv(metadata_file)

# Display the first few rows to understand the structure
head(metadata)

# Read the FASTA alignment using Biostrings
original_alignment <- readDNAStringSet(aln_file)

# View information about the alignment
cat("Number of sequences:", length(original_alignment), "\n")
cat("Sequence length:", width(original_alignment)[1], "bp\n")

# Display the first few sequence names
head(names(original_alignment))
```

## 3. Creating the Name Mapping Table

Now we'll prepare our sequence names and map them to meaningful labels:

```{r create_mapping}
# Extract sequence IDs from the alignment and remove description fields
seq_ids <- names(original_alignment)
trimmed_ids <- gsub("\\s.*", "", seq_ids, perl=TRUE)

# Verify sequence ID counts match
cat("Original sequence count:", length(original_alignment), "\n")
cat("Trimmed IDs count:", length(trimmed_ids), "\n")

# Assign the trimmed IDs to the alignment object
names(original_alignment) <- trimmed_ids

# Create a mapping dataframe that connects sequence IDs with taxonomic labels
# We also keep track of the original order in the alignment
name_swap <- data.frame(seqid = trimmed_ids) %>%
  mutate(aln_order = row_number()) %>%
  inner_join(metadata)

# Filter to include only sequences that exist in our alignment
name_swap <- name_swap %>%
  dplyr::filter(seqid %in% names(original_alignment))

# Report on mapping success
cat("Sequences successfully mapped:", nrow(name_swap), "\n")

# Filter the alignment to keep only sequences we have metadata for
filtered_alignment <- original_alignment[name_swap$seqid]

# Now replace the technical IDs with meaningful labels from label_2 column
names(filtered_alignment) <- name_swap$label_2

# Store counts for later use
n_taxa <- length(filtered_alignment)
n_pos <- width(filtered_alignment)[1]

# Examine our newly labeled sequences
head(names(filtered_alignment))
```

## 4. Trimming the Alignment

Next, we'll trim the alignment to focus on the region of interest:

```{r trim_alignment}
# Load GenomicRanges for efficient sequence manipulation
library(GenomicRanges)

# Define trimming ranges (starting from position 2226 to the end)
trimmedRanges <- GRanges(
  seqnames = names(filtered_alignment),
  ranges = IRanges(
    start = rep(2226, n_taxa),
    end = rep(n_pos, n_taxa)
  )
)

# Perform the trimming operation
trimmed_alignment <- filtered_alignment[trimmedRanges]

# Verify the trimmed alignment
cat("Trimmed alignment length:", width(trimmed_alignment)[1], "bp\n")
head(names(trimmed_alignment))
```

## 5. Creating a Function to Extract Variant Information

Let's create a reusable function to extract variant information from our alignment:

```{r variant_function}
# Function to extract variant information from alignment
extract_variant <- function(alignment, variant_name, match_pattern, reference_seq_index = 1) {
  # Find the position of the variant using the match pattern in the reference sequence
  variant_match <- vmatchPattern(match_pattern, alignment)[[reference_seq_index]]
  
  if (length(variant_match) == 0) {
    stop("Pattern '", match_pattern, "' not found in reference sequence")
  }
  
  # Get the starting position of the match
  variant_start <- start(variant_match)
  
  # Log information about the variant
  cat(variant_name, "variant found at position:", variant_start, "\n")
  
  # Number of sequences in the alignment
  n_taxa <- length(alignment)
  
  # Create genomic ranges to extract just the variant position from each sequence
  variant_range <- GRanges(
    seqnames = names(alignment),
    ranges = IRanges(
      start = rep(variant_start, n_taxa),
      end = rep(variant_start, n_taxa)
    )
  )
  
  # Extract the nucleotide at the variant position for each sequence
  variant_aln <- alignment[variant_range]
  variant_matrix <- as.matrix(variant_aln)
  
  # Replace gap characters with NA
  variant_matrix[variant_matrix == "-"] <- NA
  
  # Return the variant data as a factor
  return(factor(as.vector(variant_matrix)))
}
```

## 6. Extracting Variant Information

Now we can extract information for both variants using our function:

```{r extract_variants}
# Define our variants
variants <- data.frame(
  name = c("A204T","I211V"),
  pattern = c( "GCCGTGGCGTGGCGC", "ATCACCCGC")
)


# Extract data for each variant and add to name_swap dataframe
for (i in 1:nrow(variants)) {
  variant_name <- variants$name[i]
  variant_pattern <- variants$pattern[i]
  
  # Extract the variant data
  name_swap[[variant_name]] <- extract_variant(
    trimmed_alignment, 
    variant_name, 
    variant_pattern
  )
  
  # Check the distribution of genotypes at this position
  cat("Distribution of", variant_name, "genotypes:\n")
  print(table(name_swap[[variant_name]], useNA = "ifany"))
}

# Examine the updated dataframe with both variants
head(name_swap[, c("label_2", "I211V", "A204T", "founder_ancestry")])
```

## 7. Writing the Processed Alignment to a New File

Let's save our relabeled and trimmed alignment:

```{r write_alignment}
# Define output file path
output_alignment <- file.path(project_dir, "hpc1_nice_labels.fasta")

# Write the renamed alignment to a new file
writeXStringSet(trimmed_alignment, output_alignment, format="fasta")
cat("Renamed alignment written to:", output_alignment, "\n")
```

## 8. Building a Phylogenetic Tree

Now we'll build and visualize a phylogenetic tree from our processed alignment:

```{r build_tree}
# Load packages for phylogenetic analysis
library(ape)
library(phangorn)
library(phytools)

# Read the renamed alignment for phylogenetic analysis
hpc1_aln <- read.dna(output_alignment, format="fasta")

# Check labels in the alignment
labels(hpc1_aln)

# Convert to phangorn's phyDat format for phylogenetic analysis
hpc1_phyDat <- phyDat(hpc1_aln, type = "DNA", levels = NULL)

# Calculate distance matrix using JC69 model
# Note: You could use modelTest() to find the best model for your data
# mt <- modelTest(hpc1_phyDat)
dna_dist <- dist.ml(hpc1_phyDat, model="JC69")

# Ensure founder ancestry is properly formatted as a factor
# Note how we specify the order of levels to control the color scheme
name_swap$founder_ancestry <- factor(name_swap$founder_ancestry, levels=c("Recurrent", "Donor"))

# Build UPGMA tree and ladderize it for better visualization
hpc1_UPGMA <- ladderize(upgma(dna_dist), right = FALSE)

# Simple plot to check the tree
plot(hpc1_UPGMA, cex = 0.7, main = "UPGMA Tree Before Rotation")
```

## 9. Implementing the Tree Rotation Function

To position B73 at the top of our visualization, we need a specialized rotation function:

```{r pivot_function}
flip_tree <- function(tree){
# this function will reverse the tree plotting order
# by reversing the edges
revtree <- tree
current_edges <- tree$edge     
rev_edges <- current_edges[rev(1:nrow(current_edges)),]
revtree$edge <- rev_edges
revtree$edge.length <- rev(tree$edge.length)

is_tip <- revtree$edge[,2] <= length(revtree$tip.label)

ordered_tips <- revtree$edge[is_tip, 2]

revtree$tip.label[ordered_tips]

revtree
}

# Function to rotate a tree to position a specific tip at the top
pivot_on <- function(tree, target_tip) {
  # Check if the tree is valid
  if (is.null(tree) || !inherits(tree, "phylo")) {
    stop("Input must be a valid phylogenetic tree (phylo object)")
  }
  
  # Check if the target tip exists in the tree
  if (!target_tip %in% tree$tip.label) {
    stop("Target tip '", target_tip, "' not found in the tree.")
  }
  
  # Make a copy to modify, keeping the original intact
  rotated_tree <- tree
  
  # Get the total number of tips
  ntips <- Ntip(rotated_tree)
  
  # Get the node number corresponding to the target tip
  target_tip_node <- which(rotated_tree$tip.label == target_tip)
  
  # Get the root node (typically ntips + 1 in ape trees)
  root_node <- ntips + 1
  
  # Try to find path from root to the target tip
  path_exists <- FALSE
  tryCatch({
    node_path <- nodepath(rotated_tree, from = root_node, to = target_tip_node)
    if (length(node_path) > 0) path_exists <- TRUE
  }, error = function(e) {
    # If path from root fails, we'll try a different approach
    path_exists <- FALSE
  })
  
  # If we couldn't find a path from the root, try using a reference tip
  if (!path_exists) {
    # Use the last tip as a reference point
    reference_node <- ntips
    
    # Check that reference is not the same as target
    if (reference_node == target_tip_node) {
      reference_node <- 1  # Use the first tip instead
    }
    
    # Try to find a path between reference and target
    tryCatch({
      node_path <- nodepath(rotated_tree, from = reference_node, to = target_tip_node)
      if (length(node_path) == 0) {
        stop("Cannot find a valid path between reference and target tip")
      }
    }, error = function(e) {
      stop("Failed to find a valid path in the tree: ", e$message)
    })
  }
  
  # We only need to consider rotating internal nodes on the path
  # Internal nodes have numbers greater than ntips
  internal_nodes_on_path <- node_path[node_path > ntips]
  
  # If no internal nodes to rotate, return the original tree
  if (length(internal_nodes_on_path) == 0) {
    return(rotated_tree)
  }
  
  # Iterate through each node and rotate if necessary
  # Process nodes in order from root towards tip
  nodes_to_check <- sort(internal_nodes_on_path)
  
  for (node_to_rotate in nodes_to_check) {
    # Find the direct children of this internal node
    children <- rotated_tree$edge[rotated_tree$edge[, 1] == node_to_rotate, 2]
    
    # Check if we have exactly two children (bifurcating tree assumption)
    if (length(children) != 2) {
      warning("Node ", node_to_rotate, " is not bifurcating. Rotation might not work as expected.")
      next # Skip rotation for non-bifurcating nodes
    }
    
    # Find which child is on the path towards the target tip
    current_node_index_in_path <- which(node_path == node_to_rotate)
    
    # Make sure we're not at the end of the path
    if (current_node_index_in_path < length(node_path)) {
      child_on_path <- node_path[current_node_index_in_path + 1]
      
      # If the child on the path is the first child, rotate the node
      if (child_on_path == children[1]) {
        rotated_tree <- ape::rotate(rotated_tree, node = node_to_rotate)
      }
    }
  }
  
  # Return the rotated tree
  constrained_tree <- rotateConstr(rotated_tree,rotated_tree$tip.label)
  return(flip_tree(constrained_tree))
}
```

## 10. Applying the Rotation and Creating Visualizations for Each Variant

Now let's apply our rotation function and create plots for each variant:

```{r final_visualizations}
# Ensure row names in our metadata match the tree's tip labels
rownames(name_swap) <- name_swap$label_2

# Rotate the tree to put the first tip (B73 reference) at the top
out_tree <- pivot_on(hpc1_UPGMA, hpc1_UPGMA$tip.label[1])

# Create a function to generate our visualization with multiple variant columns
plot_output <- function(file, tree, data, 
                        columns="ancestry",
                        # Define color palette for our categories
                        pal = c(Recurrent="gold",  Donor="purple3",
                                 A="tomato",G="royalblue" ,C="forestgreen",T="orange")){ 
  # Rename founder_ancestry column to ancestry for clarity
  data <- data %>% dplyr::rename(ancestry = "founder_ancestry")
  # Extract columns to visualize: ancestry and specified variants
  X <- data[, columns]
  rownames(X) <- rownames(data)
  
  # Create the phylogenetic tree with colored dots showing metadata
  pdf(file = file, height = 13, width = 7)
  dotTree(tree, X, colors = pal, 
          labels = TRUE,           # Show taxon labels
          fsize = 0.7,             # Font size
          border = "transparent",  # No border around dots
          cex.dot = 2)             # Size of dots
  dev.off()
}

# Generate visualizations for different variant combinations
# 1. Plot with both variants by nucleotide
output_plot_both <- file.path(project_dir, "hpc1_UPGMA_both_variants.pdf")

plot_output(
  output_plot_both,
  out_tree,
  name_swap,
  columns = c("ancestry", "A204T", "I211V"))

cat("Plot with both variants saved to:", output_plot_both, "\n")

# 2. Plot just the variants with REF/ALT classification 

by_ref <- name_swap

by_ref$A204T <- c(G="ALT",A="REF")[by_ref$A204T]

by_ref$I211V <- c(G="REF",A="ALT")[by_ref$I211V]

pal_ref <- c(REF="tomato",  ALT="royalblue")

output_plot_alt_ref <- file.path(project_dir, "hpc1_UPGMA_alt_ref_variants.pdf")

plot_output(
  output_plot_alt_ref,
  out_tree,
  by_ref,
  columns = c("A204T", "I211V"),
  pal= pal_ref )

# Display the tree in the current R session (if running interactively)
plot(out_tree, main = "Rotated Tree with B73 at Top", cex = 0.7)
```
## 11. Subsetting Alignment and Tree to Donor Ancestry and B73

Now, let's create a subset analysis focusing only on taxa with donor ancestry plus the B73 reference:

```{r subset_analysis}
# First, identify B73 in our dataset
b73_label <- grep("B73", name_swap$label_2, value = TRUE)[1]
cat("B73 reference identified as:", b73_label, "\n")

# Create a subset of taxa with donor ancestry plus B73
donor_subset <- name_swap %>%
  filter(founder_ancestry == "Donor" | label_2 == b73_label)

# Check how many taxa we have in our subset
cat("Number of taxa in donor subset:", nrow(donor_subset), "\n")

# Extract the subset of sequences from our alignment
donor_alignment <- trimmed_alignment[donor_subset$label_2]

# Write the subset alignment to a file
donor_alignment_file <- file.path(project_dir, "hpc1_donor_subset.fasta")
writeXStringSet(donor_alignment, donor_alignment_file, format="fasta")
cat("Donor subset alignment written to:", donor_alignment_file, "\n")

# Build a new tree for the donor subset
donor_aln <- read.dna(donor_alignment_file, format="fasta")
donor_phyDat <- phyDat(donor_aln, type = "DNA", levels = NULL)
donor_dist <- dist.ml(donor_phyDat, model="JC69")
donor_UPGMA <- ladderize(upgma(donor_dist), right = FALSE)

# Rotate the donor tree to put B73 at the top
donor_tree <- pivot_on(donor_UPGMA, target_tip = b73_label)

# Plot the donor tree to check
plot(donor_tree, cex = 0.8, main = "Donor Subset Tree with B73 at Top")

# Prepare REF/ALT variant data for the donor subset
donor_variants <- donor_subset %>%
  select(label_2, A204T, I211V, founder_ancestry)

# Make sure rownames are set correctly
rownames(donor_variants) <- donor_variants$label_2

# Create REF/ALT coding for the donor subset
donor_ref_alt <- donor_variants

# Recode A204T: A is REF, G is ALT
donor_ref_alt$A204T <- as.character(donor_ref_alt$A204T)
donor_ref_alt$A204T[donor_ref_alt$A204T == "A"] <- "REF"
donor_ref_alt$A204T[donor_ref_alt$A204T == "G"] <- "ALT"
donor_ref_alt$A204T <- factor(donor_ref_alt$A204T)

# Recode I211V: G is REF, A is ALT
donor_ref_alt$I211V <- as.character(donor_ref_alt$I211V)
donor_ref_alt$I211V[donor_ref_alt$I211V == "G"] <- "REF"
donor_ref_alt$I211V[donor_ref_alt$I211V == "A"] <- "ALT"
donor_ref_alt$I211V <- factor(donor_ref_alt$I211V)

# Generate visualization for the donor subset with REF/ALT coding
donor_plot_file <- file.path(project_dir, "hpc1_donor_subset_ref_alt.pdf")

plot_output(
  donor_plot_file,
  donor_tree,
  donor_ref_alt,
  columns = c("A204T", "I211V"),  # Only show variant information (no ancestry since all are Donor)
  pal = c(REF="tomato", ALT="royalblue"))

cat("Donor subset plot with REF/ALT variants saved to:", donor_plot_file, "\n")

# Additional visualization showing both nucleotide and ancestry
donor_plot_nucleotide <- file.path(project_dir, "hpc1_donor_subset_nucleotide.pdf")

plot_output(
  donor_plot_nucleotide,
  donor_tree,
  donor_variants,
  columns = c("ancestry", "A204T", "I211V"),
  pal = c(Recurrent="gold", Donor="purple3", A="tomato", G="royalblue", C="forestgreen", T="orange"))

cat("Donor subset plot with nucleotide variants saved to:", donor_plot_nucleotide, "\n")

# Save the donor subset tree
donor_tree_file <- file.path(project_dir, "hpc1_donor_subset.tre")
write.tree(donor_tree, file = donor_tree_file)
cat("Donor subset tree saved to:", donor_tree_file, "\n")
```
## 12. Project File Structure

Let's examine the complete file structure of our project:

```{r file_structure, echo=FALSE, eval=TRUE}
# This chunk will be evaluated when knitting
cat("tree_plotting/\n")
cat("├── hpc1_aligned.fasta              # Input: Original alignment file\n")
cat("├── seqid_label.csv                 # Input: Metadata mapping technical IDs to meaningful names\n")
cat("├── hpc1_nice_labels.fasta          # Output: Alignment with renamed sequences\n")
cat("├── hpc1_UPGMA.tre                  # Output: Phylogenetic tree in Newick format\n")
cat("├── hpc1_UPGMA_both_variants.pdf    # Output: Visualization with both variants as nucleotides\n")
cat("├── hpc1_UPGMA_alt_ref_variants.pdf # Output: Visualization with variants as REF/ALT\n")
cat("├── hpc1_donor_subset.fasta         # Output: Alignment with only donor taxa and B73\n")
cat("├── hpc1_donor_subset.tre           # Output: Tree with only donor taxa and B73\n")
cat("├── hpc1_donor_subset_ref_alt.pdf   # Output: Donor subset visualization with REF/ALT\n")
cat("└── hpc1_donor_subset_nucleotide.pdf # Output: Donor subset with nucleotide variants\n")
```

## 13. Conclusion

This tutorial demonstrated how to:

1. Load and process FASTA alignment data using Biostrings
2. Map sequence IDs to meaningful taxonomic labels
3. Create a reusable function to extract multiple variant positions (I211V and A204T)
4. Build a phylogenetic tree using distance-based methods
5. Rotate the tree to position B73 at the top
6. Create visualizations showing the distribution of different variants across the phylogeny
7. Subset the data to focus on taxa with donor ancestry plus B73 reference
8. Generate specialized visualizations using REF/ALT genotype coding

These skills are widely applicable to comparative genomics and population genetics studies in maize and other organisms.

## 14. Troubleshooting Tips

- **Pattern not found error**: If the `vmatchPattern` function fails, verify that the pattern sequence exists in your alignment. You may need to adjust the pattern or check for sequencing errors.
- **Tree tips not matching metadata**: Ensure that the labels in your tree match exactly with the rownames in your metadata dataframe.
- **Rotation function not working**: The rotation function assumes a bifurcating tree. If your tree has multifurcations, you may need to modify the function.
- **Missing data in visualization**: Check for NA values in your metadata columns, especially the founder_ancestry and variant columns.
- **Subset analysis issues**: If the subset analysis fails, verify that there are enough sequences in the subset to build a meaningful tree (at least 4 sequences are recommended).
