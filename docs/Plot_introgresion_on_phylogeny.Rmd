---
title: "Maize Phylogeny Analysis with Multiple Variants"
author: "Maize Genetics Lab"
date: "`r Sys.Date()`"
output:
  github_document:
    html_preview: false
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

This tutorial walks through a complete workflow for processing maize genetic data, focusing on:

1. Relabeling sequence identifiers in a FASTA alignment with meaningful taxonomic labels
2. Extracting genotype information at multiple variant positions (I211V and A204T)
3. Creating a phylogenetic tree with ancestry and variant information
4. Rotating the tree to position the B73 reference genome at the top

## 1. Setting up the Environment

First, let's install and load the necessary packages:

```{r load_packages}
# Install required packages if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

if (!requireNamespace("Biostrings", quietly = TRUE))
  BiocManager::install("Biostrings")

if (!requireNamespace("tidyverse", quietly = TRUE))
  install.packages("tidyverse")

# Load packages
library(Biostrings)  # For FASTA manipulation
library(tidyverse)   # For data manipulation
```

## 2. Reading Input Files

Let's set up our directory structure and read our input files:

```{r read_inputs}
# Create a project directory if it doesn't exist
project_dir <- "~/Desktop/tree_plotting"
if (!dir.exists(project_dir)) {
  dir.create(project_dir)
}

# Set file paths within the project directory
aln_file <- file.path(project_dir, "hpc1_aligned.fasta")
metadata_file <- file.path(project_dir, "seqid_label.csv")

# Read the mapping table with taxonomic metadata
metadata <- read.csv(metadata_file)

# Display the first few rows to understand the structure
head(metadata)

# Read the FASTA alignment using Biostrings
original_alignment <- readDNAStringSet(aln_file)

# View information about the alignment
cat("Number of sequences:", length(original_alignment), "\n")
cat("Sequence length:", width(original_alignment)[1], "bp\n")

# Display the first few sequence names
head(names(original_alignment))
```

## 3. Creating the Name Mapping Table

Now we'll prepare our sequence names and map them to meaningful labels:

```{r create_mapping}
# Extract sequence IDs from the alignment and remove description fields
seq_ids <- names(original_alignment)
trimmed_ids <- gsub("\\s.*", "", seq_ids, perl=TRUE)

# Verify sequence ID counts match
cat("Original sequence count:", length(original_alignment), "\n")
cat("Trimmed IDs count:", length(trimmed_ids), "\n")

# Assign the trimmed IDs to the alignment object
names(original_alignment) <- trimmed_ids

# Create a mapping dataframe that connects sequence IDs with taxonomic labels
# We also keep track of the original order in the alignment
name_swap <- data.frame(seqid = trimmed_ids) %>%
  mutate(aln_order = row_number()) %>%
  inner_join(metadata)

# Filter to include only sequences that exist in our alignment
name_swap <- name_swap %>%
  dplyr::filter(seqid %in% names(original_alignment))

# Report on mapping success
cat("Sequences successfully mapped:", nrow(name_swap), "\n")

# Filter the alignment to keep only sequences we have metadata for
filtered_alignment <- original_alignment[name_swap$seqid]

# Now replace the technical IDs with meaningful labels from label_2 column
names(filtered_alignment) <- name_swap$label_2

# Store counts for later use
n_taxa <- length(filtered_alignment)
n_pos <- width(filtered_alignment)[1]

# Examine our newly labeled sequences
head(names(filtered_alignment))
```

## 4. Trimming the Alignment

Next, we'll trim the alignment to focus on the region of interest:

```{r trim_alignment}
# Load GenomicRanges for efficient sequence manipulation
library(GenomicRanges)

# Define trimming ranges (starting from position 2226 to the end)
trimmedRanges <- GRanges(
  seqnames = names(filtered_alignment),
  ranges = IRanges(
    start = rep(2226, n_taxa),
    end = rep(n_pos, n_taxa)
  )
)

# Perform the trimming operation
trimmed_alignment <- filtered_alignment[trimmedRanges]

# Verify the trimmed alignment
cat("Trimmed alignment length:", width(trimmed_alignment)[1], "bp\n")
head(names(trimmed_alignment))
```

## 5. Creating a Function to Extract Variant Information

Let's create a reusable function to extract variant information from our alignment:

```{r variant_function}
# Function to extract variant information from alignment
extract_variant <- function(alignment, variant_name, match_pattern, reference_seq_index = 1) {
  # Find the position of the variant using the match pattern in the reference sequence
  variant_match <- vmatchPattern(match_pattern, alignment)---
title: "Maize Phylogeny Analysis with Multiple Variants"
author: "Maize Genetics Lab"
date: "`r Sys.Date()`"
output:
  github_document:
    html_preview: false
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

This tutorial walks through a complete workflow for processing maize genetic data, focusing on:

1. Relabeling sequence identifiers in a FASTA alignment with meaningful taxonomic labels
2. Extracting genotype information at multiple variant positions (I211V and A204T)
3. Creating a phylogenetic tree with ancestry and variant information
4. Rotating the tree to position the B73 reference genome at the top

## 1. Setting up the Environment

First, let's install and load the necessary packages:

```{r load_packages}
# Install required packages if not already installed
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

if (!requireNamespace("Biostrings", quietly = TRUE))
  BiocManager::install("Biostrings")

if (!requireNamespace("tidyverse", quietly = TRUE))
  install.packages("tidyverse")

# Load packages
library(Biostrings)  # For FASTA manipulation
library(tidyverse)   # For data manipulation
```

## 2. Reading Input Files

Let's set up our directory structure and read our input files:

```{r read_inputs}
# Create a project directory if it doesn't exist
project_dir <- "tree_plotting"
if (!dir.exists(project_dir)) {
  dir.create(project_dir)
}

# Set file paths within the project directory
aln_file <- file.path(project_dir, "hpc1_aligned.fasta")
metadata_file <- file.path(project_dir, "seqid_label.csv")

# Read the mapping table with taxonomic metadata
metadata <- read.csv(metadata_file)

# Display the first few rows to understand the structure
head(metadata)

# Read the FASTA alignment using Biostrings
original_alignment <- readDNAStringSet(aln_file)

# View information about the alignment
cat("Number of sequences:", length(original_alignment), "\n")
cat("Sequence length:", width(original_alignment)[1], "bp\n")

# Display the first few sequence names
head(names(original_alignment))
```

## 3. Creating the Name Mapping Table

Now we'll prepare our sequence names and map them to meaningful labels:

```{r create_mapping}
# Extract sequence IDs from the alignment and remove description fields
seq_ids <- names(original_alignment)
trimmed_ids <- gsub("\\s.*", "", seq_ids, perl=TRUE)

# Verify sequence ID counts match
cat("Original sequence count:", length(original_alignment), "\n")
cat("Trimmed IDs count:", length(trimmed_ids), "\n")

# Assign the trimmed IDs to the alignment object
names(original_alignment) <- trimmed_ids

# Create a mapping dataframe that connects sequence IDs with taxonomic labels
# We also keep track of the original order in the alignment
name_swap <- data.frame(seqid = trimmed_ids) %>%
  mutate(aln_order = row_number()) %>%
  inner_join(metadata)

# Filter to include only sequences that exist in our alignment
name_swap <- name_swap %>%
  dplyr::filter(seqid %in% names(original_alignment))

# Report on mapping success
cat("Sequences successfully mapped:", nrow(name_swap), "\n")

# Filter the alignment to keep only sequences we have metadata for
filtered_alignment <- original_alignment[name_swap$seqid]

# Now replace the technical IDs with meaningful labels from label_2 column
names(filtered_alignment) <- name_swap$label_2

# Store counts for later use
n_taxa <- length(filtered_alignment)
n_pos <- width(filtered_alignment)[1]

# Examine our newly labeled sequences
head(names(filtered_alignment))
```

## 4. Trimming the Alignment

Next, we'll trim the alignment to focus on the region of interest:

```{r trim_alignment}
# Load GenomicRanges for efficient sequence manipulation
library(GenomicRanges)

# Define trimming ranges (starting from position 2226 to the end)
trimmedRanges <- GRanges(
  seqnames = names(filtered_alignment),
  ranges = IRanges(
    start = rep(2226, n_taxa),
    end = rep(n_pos, n_taxa)
  )
)

# Perform the trimming operation
trimmed_alignment <- filtered_alignment[trimmedRanges]

# Verify the trimmed alignment
cat("Trimmed alignment length:", width(trimmed_alignment)[1], "bp\n")
head(names(trimmed_alignment))
```

## 5. Creating a Function to Extract Variant Information

Let's create a reusable function to extract variant information from our alignment:

```{r variant_function}
# Function to extract variant information from alignment
extract_variant <- function(alignment, variant_name, match_pattern, reference_seq_index = 1) {
  # Find the position of the variant using the match pattern in the reference sequence
  variant_match <- vmatchPattern(match_pattern, alignment)[[reference_seq_index]]
  
  if (length(variant_match) == 0) {
    stop("Pattern '", match_pattern, "' not found in reference sequence")
  }
  
  # Get the starting position of the match
  variant_start <- start(variant_match)
  
  # Log information about the variant
  cat(variant_name, "variant found at position:", variant_start, "\n")
  
  # Number of sequences in the alignment
  n_taxa <- length(alignment)
  
  # Create genomic ranges to extract just the variant position from each sequence
  variant_range <- GRanges(
    seqnames = names(alignment),
    ranges = IRanges(
      start = rep(variant_start, n_taxa),
      end = rep(variant_start, n_taxa)
    )
  )
  
  # Extract the nucleotide at the variant position for each sequence
  variant_aln <- alignment[variant_range]
  variant_matrix <- as.matrix(variant_aln)
  
  # Replace gap characters with NA
  variant_matrix[variant_matrix == "-"] <- NA
  
  # Return the variant data as a factor
  return(factor(as.vector(variant_matrix)))
}
```

## 6. Extracting Variant Information

Now we can extract information for both variants using our function:

```{r extract_variants}
# Define our variants
variants <- data.frame(
  name = c("A204T","I211V"),
  pattern = c( "GCCGTGGCGTGGCGC", "ATCACCCGC")
)


# Extract data for each variant and add to name_swap dataframe
for (i in 1:nrow(variants)) {
  variant_name <- variants$name[i]
  variant_pattern <- variants$pattern[i]
  
  # Extract the variant data
  name_swap[[variant_name]] <- extract_variant(
    trimmed_alignment, 
    variant_name, 
    variant_pattern
  )
  
  # Check the distribution of genotypes at this position
  cat("Distribution of", variant_name, "genotypes:\n")
  print(table(name_swap[[variant_name]], useNA = "ifany"))
}

# Examine the updated dataframe with both variants
head(name_swap[, c("label_2", "I211V", "A204T", "founder_ancestry")])
```

## 7. Writing the Processed Alignment to a New File

Let's save our relabeled and trimmed alignment:

```{r write_alignment}
# Define output file path
output_alignment <- file.path(project_dir, "hpc1_nice_labels.fasta")

# Write the renamed alignment to a new file
writeXStringSet(trimmed_alignment, output_alignment, format="fasta")
cat("Renamed alignment written to:", output_alignment, "\n")
```

## 8. Building a Phylogenetic Tree

Now we'll build and visualize a phylogenetic tree from our processed alignment:

```{r build_tree}
# Load packages for phylogenetic analysis
library(ape)
library(phangorn)
library(phytools)

# Read the renamed alignment for phylogenetic analysis
hpc1_aln <- read.dna(output_alignment, format="fasta")

# Check labels in the alignment
labels(hpc1_aln)

# Convert to phangorn's phyDat format for phylogenetic analysis
hpc1_phyDat <- phyDat(hpc1_aln, type = "DNA", levels = NULL)

# Calculate distance matrix using JC69 model
# Note: You could use modelTest() to find the best model for your data
# mt <- modelTest(hpc1_phyDat)
dna_dist <- dist.ml(hpc1_phyDat, model="JC69")

# Ensure founder ancestry is properly formatted as a factor
# Note how we specify the order of levels to control the color scheme
name_swap$founder_ancestry <- factor(name_swap$founder_ancestry, levels=c("Recurrent", "Donor"))

# Build UPGMA tree and ladderize it for better visualization
hpc1_UPGMA <- ladderize(upgma(dna_dist), right = FALSE)

# Simple plot to check the tree
plot(hpc1_UPGMA, cex = 0.7, main = "UPGMA Tree Before Rotation")
```

## 9. Implementing the Tree Rotation Function

To position B73 at the top of our visualization, we need a specialized rotation function:

```{r pivot_function}
# Function to rotate a tree to position a specific tip at the top
pivot_on <- function(x, target_tip){
  target_tip_label <- target_tip
  tree <- x
  
  # Make a copy to modify, keeping the original intact
  rotated_tree <- tree
  
  # Check if the target tip exists in the tree
  if (!target_tip_label %in% rotated_tree$tip.label) {
    stop("Target tip '", target_tip_label, "' not found in the tree.")
  }
  
  # Get the total number of tips
  ntips <- Ntip(rotated_tree)
  
  # Get the node number corresponding to the target tip
  target_tip_node <- which(rotated_tree$tip.label == target_tip_label)
  
  # Use a reference node to establish a path
  # Here we're using the last tip as our reference
  reference_node <- ntips 
  
  # Find the path from the reference node to our target tip
  node_path <- nodepath(rotated_tree, from = reference_node, to = target_tip_node)
  
  # We only need to consider rotating internal nodes on the path
  # Internal nodes have numbers greater than ntips
  internal_nodes_on_path <- node_path[node_path > ntips]
  
  # Iterate through each node and rotate if necessary
  if (length(internal_nodes_on_path) > 0) {
    # Process nodes in order from root towards tip
    nodes_to_check <- sort(internal_nodes_on_path)
    
    for (node_to_rotate in nodes_to_check) {
      # Find the direct children of this internal node
      children <- rotated_tree$edge[rotated_tree$edge[, 1] == node_to_rotate, 2]
      
      # Check if we have exactly two children (bifurcating tree assumption)
      if (length(children) != 2) {
        warning("Node ", node_to_rotate, " is not bifurcating. Rotation might not work as expected.")
        next # Skip rotation for non-bifurcating nodes
      }
      
      # Find which child is on the path towards the target tip
      current_node_index_in_path <- which(node_path == node_to_rotate)
      child_on_path <- node_path[current_node_index_in_path + 1]
      
      # If the child on the path is the first child, rotate the node
      # This will make our target tip appear higher in the visualization
      if (child_on_path == children[1]) {
        rotated_tree <- rotate(rotated_tree, node = node_to_rotate)
      }
    }
  }
  
  # Return the rotated tree
  return(rotated_tree)
}
```

## 10. Applying the Rotation and Creating Visualizations for Each Variant

Now let's apply our rotation function and create plots for each variant:

```{r final_visualizations}
# Ensure row names in our metadata match the tree's tip labels
rownames(name_swap) <- name_swap$label_2

# Rotate the tree to put the first tip (B73 reference) at the top
out_tree <- pivot_on(hpc1_UPGMA, hpc1_UPGMA$tip.label[1])

# Create a function to generate our visualization with multiple variant columns
plot_output <- function(file, tree, data, 
                        columns="ancestry",
                        # Define color palette for our categories
                        pal = c(Recurrent="gold",  Donor="purple3",
                                 A="tomato",G="royalblue" ,C="forestgreen",T="orange")){ 
  # Rename founder_ancestry column to ancestry for clarity
  data <- data %>% dplyr::rename(ancestry = "founder_ancestry")
  # Extract columns to visualize: ancestry and specified variants
  X <- data[, columns]
  rownames(X) <- rownames(data)
  
  # Create the phylogenetic tree with colored dots showing metadata
  pdf(file = file, height = 13, width = 7)
  dotTree(tree, X, colors = pal, 
          labels = TRUE,           # Show taxon labels
          fsize = 0.7,             # Font size
          border = "transparent",  # No border around dots
          cex.dot = 2)             # Size of dots
  dev.off()
}

# Generate visualizations for different variant combinations
# 1. Plot with both variants by nucleotide
output_plot_both <- file.path(project_dir, "hpc1_UPGMA_both_variants.pdf")

plot_output(
  output_plot_both,
  out_tree,
  name_swap,
  columns = c("ancestry", "A204T", "I211V"))

cat("Plot with both variants saved to:", output_plot_both, "\n")

# 2. Plot with ALT/REF classification just the variants

by_ref <- name_swap

by_ref$A204T <- c(G="ALT",A="REF")[by_ref$A204T]

by_ref$I211V <- c(G="REF",A="ALT")[by_ref$I211V]

pal_ref <- c(REF="tomato",  ALT="royalblue")

output_plot_alt_ref <- file.path(project_dir, "hpc1_UPGMA_alt_ref_variants.pdf")

plot_output(
  output_plot_alt_ref,
  out_tree,
  by_ref,
  columns = c("A204T", "I211V"),
  pal= pal_ref )

# Display the tree in the current R session (if running interactively)
plot(out_tree, main = "Rotated Tree with B73 at Top", cex = 0.7)
```

## 11. Project File Structure

Let's examine the complete file structure of our project:

```{r file_structure, echo=FALSE, eval=TRUE}
# This chunk will be evaluated when knitting
cat("tree_plotting/\n")
cat("├── hpc1_aligned.fasta        # Input: Original alignment file\n")
cat("├── seqid_label.csv           # Input: Metadata mapping technical IDs to meaningful names\n")
cat("├── hpc1_nice_labels.fasta    # Output: Alignment with renamed sequences\n")
cat("├── hpc1_UPGMA.tre            # Output: Phylogenetic tree in Newick format\n")
cat("├── hpc1_UPGMA_I211V.pdf      # Output: Visualization with I211V variant\n")
cat("├── hpc1_UPGMA_A204T.pdf      # Output: Visualization with A204T variant\n")
cat("└── hpc1_UPGMA_both_variants.pdf  # Output: Visualization with both variants\n")
```

## 12. Conclusion

This tutorial demonstrated how to:

1. Load and process FASTA alignment data using Biostrings
2. Map sequence IDs to meaningful taxonomic labels
3. Create a reusable function to extract multiple variant positions (I211V and A204T)
4. Build a phylogenetic tree using distance-based methods
5. Rotate the tree to position B73 at the top
6. Create visualizations showing the distribution of different variants across the phylogeny

These skills are widely applicable to comparative genomics and population genetics studies in maize and other organisms.

## 13. Troubleshooting Tips

- **Pattern not found error**: If the `vmatchPattern` function fails, verify that the pattern sequence exists in your alignment. You may need to adjust the pattern or check for sequencing errors.
- **Tree tips not matching metadata**: Ensure that the labels in your tree match exactly with the rownames in your metadata dataframe.
- **Rotation function not working**: The rotation function assumes a bifurcating tree. If your tree has multifurcations, you may need to modify the function.
- **Missing data in visualization**: Check for NA values in your metadata columns, especially the founder_ancestry and variant columns.
  
  if (length(variant_match) == 0) {
    stop("Pattern '", match_pattern, "' not found in reference sequence")
  }
  
  # Get the starting position of the match
  variant_start <- start(variant_match)
  
  # Log information about the variant
  cat(variant_name, "variant found at position:", variant_start, "\n")
  
  # Number of sequences in the alignment
  n_taxa <- length(alignment)
  
  # Create genomic ranges to extract just the variant position from each sequence
  variant_range <- GRanges(
    seqnames = names(alignment),
    ranges = IRanges(
      start = rep(variant_start, n_taxa),
      end = rep(variant_start, n_taxa)
    )
  )
  
  # Extract the nucleotide at the variant position for each sequence
  variant_aln <- alignment[variant_range]
  variant_matrix <- as.matrix(variant_aln)
  
  # Replace gap characters with NA
  variant_matrix[variant_matrix == "-"] <- NA
  
  # Return the variant data as a factor
  return(factor(as.vector(variant_matrix)))
}
```

## 6. Extracting Variant Information

Now we can extract information for both variants using our function:

```{r extract_variants}
# Define our variants
variants <- data.frame(
  name = c("I211V", "A204T"),
  pattern = c("ATCACCCGC", "GCCGTGGCGTGGCGC")
)

# Extract data for each variant and add to name_swap dataframe
for (i in 1:nrow(variants)) {
  variant_name <- variants$name[i]
  variant_pattern <- variants$pattern[i]
  
  # Extract the variant data
  name_swap[[variant_name]] <- extract_variant(
    trimmed_alignment, 
    variant_name, 
    variant_pattern
  )
  
  # Check the distribution of genotypes at this position
  cat("Distribution of", variant_name, "genotypes:\n")
  print(table(name_swap[[variant_name]], useNA = "ifany"))
}

# Examine the updated dataframe with both variants
head(name_swap[, c("label_2", "I211V", "A204T", "founder_ancestry")])
```

## 7. Writing the Processed Alignment to a New File

Let's save our relabeled and trimmed alignment:

```{r write_alignment}
# Define output file path
output_alignment <- file.path(project_dir, "hpc1_nice_labels.fasta")

# Write the renamed alignment to a new file
writeXStringSet(trimmed_alignment, output_alignment, format="fasta")
cat("Renamed alignment written to:", output_alignment, "\n")
```

## 8. Building a Phylogenetic Tree

Now we'll build and visualize a phylogenetic tree from our processed alignment:

```{r build_tree}
# Load packages for phylogenetic analysis
library(ape)
library(phangorn)
library(phytools)

# Read the renamed alignment for phylogenetic analysis
hpc1_aln <- read.dna(output_alignment, format="fasta")

# Check labels in the alignment
labels(hpc1_aln)

# Convert to phangorn's phyDat format for phylogenetic analysis
hpc1_phyDat <- phyDat(hpc1_aln, type = "DNA", levels = NULL)

# Calculate distance matrix using JC69 model
# Note: You could use modelTest() to find the best model for your data
# mt <- modelTest(hpc1_phyDat)
dna_dist <- dist.ml(hpc1_phyDat, model="JC69")

# Ensure founder ancestry is properly formatted as a factor
# Note how we specify the order of levels to control the color scheme
name_swap$founder_ancestry <- factor(name_swap$founder_ancestry, levels=c("Recurrent", "Donor"))

# Build UPGMA tree and ladderize it for better visualization
hpc1_UPGMA <- ladderize(upgma(dna_dist), right = FALSE)

# Simple plot to check the tree
plot(hpc1_UPGMA, cex = 0.7, main = "UPGMA Tree Before Rotation")
```

## 9. Implementing the Tree Rotation Function

To position B73 at the top of our visualization, we need a specialized rotation function:

```{r pivot_function}
# Function to rotate a tree to position a specific tip at the top
pivot_on <- function(x, target_tip){
  target_tip_label <- target_tip
  tree <- x
  
  # Make a copy to modify, keeping the original intact
  rotated_tree <- tree
  
  # Check if the target tip exists in the tree
  if (!target_tip_label %in% rotated_tree$tip.label) {
    stop("Target tip '", target_tip_label, "' not found in the tree.")
  }
  
  # Get the total number of tips
  ntips <- Ntip(rotated_tree)
  
  # Get the node number corresponding to the target tip
  target_tip_node <- which(rotated_tree$tip.label == target_tip_label)
  
  # Use a reference node to establish a path
  # Here we're using the last tip as our reference
  reference_node <- ntips 
  
  # Find the path from the reference node to our target tip
  node_path <- nodepath(rotated_tree, from = reference_node, to = target_tip_node)
  
  # We only need to consider rotating internal nodes on the path
  # Internal nodes have numbers greater than ntips
  internal_nodes_on_path <- node_path[node_path > ntips]
  
  # Iterate through each node and rotate if necessary
  if (length(internal_nodes_on_path) > 0) {
    # Process nodes in order from root towards tip
    nodes_to_check <- sort(internal_nodes_on_path)
    
    for (node_to_rotate in nodes_to_check) {
      # Find the direct children of this internal node
      children <- rotated_tree$edge[rotated_tree$edge[, 1] == node_to_rotate, 2]
      
      # Check if we have exactly two children (bifurcating tree assumption)
      if (length(children) != 2) {
        warning("Node ", node_to_rotate, " is not bifurcating. Rotation might not work as expected.")
        next # Skip rotation for non-bifurcating nodes
      }
      
      # Find which child is on the path towards the target tip
      current_node_index_in_path <- which(node_path == node_to_rotate)
      child_on_path <- node_path[current_node_index_in_path + 1]
      
      # If the child on the path is the first child, rotate the node
      # This will make our target tip appear higher in the visualization
      if (child_on_path == children[1]) {
        rotated_tree <- rotate(rotated_tree, node = node_to_rotate)
      }
    }
  }
  
  # Return the rotated tree
  return(rotated_tree)
}
```

## 10. Applying the Rotation and Creating Visualizations for Each Variant

Now let's apply our rotation function and create plots for each variant:

```{r final_visualizations}
# Ensure row names in our metadata match the tree's tip labels
rownames(name_swap) <- name_swap$label_2

# Rotate the tree to put the first tip (B73 reference) at the top
out_tree <- pivot_on(hpc1_UPGMA, hpc1_UPGMA$tip.label[1])

# Create a function to generate our visualization with multiple variant columns
plot_output <- function(file, tree, data, variants){ 
  # Rename founder_ancestry column to ancestry for clarity
  data <- data %>% dplyr::rename(ancestry = "founder_ancestry")
  
  # Define color palette for our categories
  pal <- c("gold", "purple3", "tomato", "royalblue", "forestgreen", "orange")
  names(pal) <- c("Recurrent", "Donor", "A", "G", "C", "T")
  
  # Extract columns to visualize: ancestry and specified variants
  X <- data[, c("ancestry", variants)]
  rownames(X) <- rownames(data)
  
  # Create the phylogenetic tree with colored dots showing metadata
  pdf(file = file, height = 13, width = 7)
  dotTree(tree, X, colors = pal, 
          labels = TRUE,           # Show taxon labels
          fsize = 0.7,             # Font size
          border = "transparent",  # No border around dots
          cex.dot = 2)             # Size of dots
  dev.off()
}

# Generate visualizations for different variant combinations
# 1. Plot with both variants
output_plot_both <- file.path(project_dir, "hpc1_UPGMA_both_variants.pdf")
plot_output(output_plot_both, out_tree, name_swap, c("I211V", "A204T"))
cat("Plot with both variants saved to:", output_plot_both, "\n")

# 2. Plot with just I211V (for comparison with original)
output_plot_I211V <- file.path(project_dir, "hpc1_UPGMA_I211V.pdf")
plot_output(output_plot_I211V, out_tree, name_swap, "I211V")
cat("Plot with I211V saved to:", output_plot_I211V, "\n")

# 3. Plot with just A204T
output_plot_A204T <- file.path(project_dir, "hpc1_UPGMA_A204T.pdf")
plot_output(output_plot_A204T, out_tree, name_swap, "A204T")
cat("Plot with A204T saved to:", output_plot_A204T, "\n")

# Save the tree in Newick format for future use
output_tree <- file.path(project_dir, "hpc1_UPGMA.tre")
write.tree(out_tree, file = output_tree)
cat("Tree saved to:", output_tree, "\n")

# Display the tree in the current R session (if running interactively)
plot(out_tree, main = "Rotated Tree with B73 at Top", cex = 0.7)
```

## 11. Project File Structure

Let's examine the complete file structure of our project:

```{r file_structure, echo=FALSE, eval=TRUE}
# This chunk will be evaluated when knitting
cat("tree_plotting/\n")
cat("├── hpc1_aligned.fasta        # Input: Original alignment file\n")
cat("├── seqid_label.csv           # Input: Metadata mapping technical IDs to meaningful names\n")
cat("├── hpc1_nice_labels.fasta    # Output: Alignment with renamed sequences\n")
cat("├── hpc1_UPGMA.tre            # Output: Phylogenetic tree in Newick format\n")
cat("├── hpc1_UPGMA_I211V.pdf      # Output: Visualization with I211V variant\n")
cat("├── hpc1_UPGMA_A204T.pdf      # Output: Visualization with A204T variant\n")
cat("└── hpc1_UPGMA_both_variants.pdf  # Output: Visualization with both variants\n")
```

## 12. Conclusion

This tutorial demonstrated how to:

1. Load and process FASTA alignment data using Biostrings
2. Map sequence IDs to meaningful taxonomic labels
3. Create a reusable function to extract multiple variant positions (I211V and A204T)
4. Build a phylogenetic tree using distance-based methods
5. Rotate the tree to position B73 at the top
6. Create visualizations showing the distribution of different variants across the phylogeny

These skills are widely applicable to comparative genomics and population genetics studies in maize and other organisms.

## 13. Troubleshooting Tips

- **Pattern not found error**: If the `vmatchPattern` function fails, verify that the pattern sequence exists in your alignment. You may need to adjust the pattern or check for sequencing errors.
- **Tree tips not matching metadata**: Ensure that the labels in your tree match exactly with the rownames in your metadata dataframe.
- **Rotation function not working**: The rotation function assumes a bifurcating tree. If your tree has multifurcations, you may need to modify the function.
- **Missing data in visualization**: Check for NA values in your metadata columns, especially the founder_ancestry and variant columns.